# 浏览器HTTP缓存机制
> http缓存机制是一种web性能优化的手段，对于从事web行业的我们很有必要去弄懂，起初我仅仅只是知道浏览器会对请求的静态文件进行缓存，至于如何缓存，为什么缓存并不知其所以然。在这里结合自己所学及理解，用简短的文字来说明。

我们在访问百度首页的时候，会发现不管怎么刷新页面，静态资源基本都是返回 200（from cache）？200？缓存状态不应该是304？

![](http://www.gushisan.cn/blog1.png)
让我们带着疑问继续看下去
# 浏览器加载一个页面的流程：
- 浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器
- 如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源
- 如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存

# 强缓存
> 命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。
## Expires
- Expires是http1.0时代处理缓存的方式，用来启用缓存和定义缓存时间。Expires的值对应一个GMT（格林尼治时间），比如“Wed, 24 Jun 2020 03:33:06 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。
- 与之对应的有Pragma字段，当该字段值为“no-cache”的时候禁止缓存，即每次都发送新的请求。
- 需要注意的是Pragma字段的优先级会更高，也就是说当Pragma设置为禁用，又给Expires定义一个还未到期的时间，这是还是会发起新的请求
- 缺点：响应报文中Expires所定义的缓存时间是相对服务器上的时间而言的，如果客户端上的时间跟服务器上的时间不一致，那缓存时间可能就没意义了

## Cache-Control
> 上述的Expires时间是相对服务器而言，无法保证和客户端时间统一,http1.1新增了 Cache-Control 来定义缓存过期时间,若报文中同时出现了 Pragma、Expires 和 Cache-Control，会以 Cache-Control 为准

#### 作为Request Headres时候可取值
- no-cache > 告知服务器不直接使用缓存，要求原服务器发送请求
- no-store > 所有内容都不会被保存到缓存或Internet临时文件中
- max-age=delta-seconds > 告知服务器客户端希望接收一个存在时间（Age）不大于delta-seconds秒的资源
- max-stale [= delta-seconds] > 告知服务器客户端愿意接收一个超过缓存时间的资源，若有定义delta-seconds则为delta-seconds秒，若没有定义则为任意超出时间
- min-fresh=delta-seconds > 告知服务器客户端希望接收一个在小于delta-seconds秒内被更新过的资源
#### 作为Response Headres时候可取值
- public > 表明任何情况下都得缓存该资源（即使是需要http认证的资源）
- private[="field-name"] > 表明返回报文中全部或部分（若指定了field-name则为field-name的字段数据）仅开放给部分用户（服务器指定的share-user）做缓存使用，其他用户则不能缓存这些数据
- no-cache > 不直接使用缓存，要求向服务器发起（新鲜度校验）请求
- no-store > 所有内容都不会被保存到缓存或Internet临时文件中
- no-transform > 告知客户端缓存文件时不得对实体数据做任何更改
- max-age=delta-seconds > 告知客户端该资源在delta-seconds秒内是新鲜的，无需向服务器发送请求

# 协商缓存
> 若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。