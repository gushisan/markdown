# 你可能不知道的前端冷知识
> 此文档主要记录开发过程中有一些不知其所以然的东西，将这些东西进行更深入的学习，并记录在此。对于知识我们要知其然知其所以然。

## 关于跳出循环
- for循环只能使用continue结束本次循环，break结束当前循环。不能使用return，会报错
- forEach循环不能使用continue和break会报错，return无法结束循环（只能达到continue的效果），想结束foreach循环只能抛出错误

```js
for (let i = 1; i < 3; i++) {
  if (i === 2) {
    return // Uncaught SyntaxError: Illegal return statement
  }
  console.log(i)
}
console.log('end')
```
return的作用是指定函数的返回值,在这里for循环的外部没有函数包裹,所以会报错,开发过程中有很多在循环中return的情况,这里我们要弄清楚

```js
let arr = ['a', 'b', 'c', 'd']

arr.forEach((ele, index) => {
  if (index === 2) {
    return // 这里如果改成break/continue都会报错
  }
  console.log(ele)
})

console.log('end')
// 输出结果: a, b, d, end
```
从上面的代码中可以看出,return的效果只是结束了当次循环,并没有跳出循环
> forEach()无法在所有元素都传递给调用的函数之前终止遍历 -----摘抄《JavaScript权威指南》

解决方法:使用every或者some来代替forEach,或者使用try catch将循环包裹在循环内部抛出错误来结束

## 0.1+0.2为什么不等于0.3
```js
console.log(0.1+0.2)
// 输出结果: 0.30000000000000004
```
通过查阅资料得知JavaScript内部采用的IEEE 754标准,number类型默认为双精度浮点型（64位）,然后我发现了以下的问题:
- 首先我们都知道计算机内部存储是采用的二进制
- 将0.1转为二进制是无限循环小数,0.2也是无线循环小数,在存储的过程中有没有可能会出现精度丢失呢

```js
let a = 0.1
console.log(a.toString(2))
// 输出结果: 0.0001100110011001100110011001100110011001100110011001101

let b = 0.2
console.log(b.toString(2))
// 输出结果: 0.001100110011001100110011001100110011001100110011001101

let c = 0.1+0.2
console.log(c.toString(2))
// 输出结果: 0.0100110011001100110011001100110011001100110011001101

let d = 0.3
console.log(d.toString(2))
// 输出结果: 0.010011001100110011001100110011001100110011001100110011

console.log(Math.pow(2, 50) + 0.1)
// 输出结果: 1125899906842624
console.log(Math.pow(2, 49) + 0.1)
// 输出结果: 562949953421312.1
```
带着疑问经过一系列尝试,得出结论在涉及到长度溢出的时候会出现精度丢失问题,当长度溢出会默认做截取,从上面的输出中可以看出0.1+0.2转成二进制后大于0.3直接转二进制.当整数部分溢出也会出现截取现象

## ==和===的区别
> 为什么ESLint推荐使用===代替==呢,肯定是有其中的原因的
- == 代表相等,如果==两边是不同类型的,会隐式的转化为相同类型的进行比较
- === 代表严格相等, 如果===两边是不同类型直接为false
```js
console.log(0 == false) // true
console.log(0 === false) // false
console.log(Number(false)) // 0
```
从上面的输出可以看出,  `0==false`中间经历了一次隐式的`Number(false)`将==两边都转化为数字再进行比较的,而===两边类型不同直接为false,那么隐式的类型转换有什么弊端呢

```js
let x = 1
let obj = {
  valueOf: () => {
    x = 2
    return 0 
  }
}
console.log(obj == 0, x) // true, 2
// 可能导致意料之外的改变
```
以上代码中我并不想去改变x的值,但是obj转number的时候,obj会调用自身的valueOf方法,导致了x值的改变,这次改变是意料之外的

```js
let x = 1
let obj = {
  valueOf: () => {
    return {}
  },
  toString: () => {
    return {}
  }
}
console.log(obj == 0, x)
// Uncaught TypeError: Cannot convert object to primitive value
// 可能会出现意料之外的报错
```
当valueOf和toString都没有返回时,会抛出异常
> 对象转化成数字的规则：
> - 如果对象有valueOf方法，则调用该方法，并返回相应的结果
> - 当调用valueOf返回的依然不是数字，则会调用对象的toString方法，并返回相应的结果
> - 否则抛出异常

## Event loop
> event loop是计算机系统的一种运行机制，JavaScript就采用这种机制，来解决单线程运行带来的一些问题。弄懂这个就能清楚的知道js到底是怎样去执行的。

我们需要知道，js是单线程的，遇见异步操作会先进异步队列，而不是立即执行，我们需要知道以下两个概念:

#### 宏队列，macrotask，这些异步任务包括：
- setTimeout
- setInterval
- setImmediate (Node)
- requestAnimationFrame (浏览器)
- I/O
- UI rendering (浏览器)
  
#### 微队列，microtask，这些异步任务包括：
- Promise
- Object.observe
- MutationObserver
- process.nextTick (Node)

![](http://www.gushisan.cn/def.png)

#### 代码执行步骤

- 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）
- 全局Script代码执行完毕后，调用栈Stack会清空
- 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1
- 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行
- microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空
- 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行
- 执行完毕后，调用栈Stack为空
- 重复第3-7个步骤

简单点概括就是同步代码顺序执行，碰到微任务进微队列，碰到宏任务进宏队列。同步代码执行完先将微队列中的所有任务执行完，微队列执行过程中碰到的微任务放到队列尾部这次一并执行。微队列执行完毕后执行宏队列头部的任务，执行完成之后再进微队列，执行完所有的微任务，依次循环，直到所有任务执行完毕

```js
console.log(1)

setTimeout(() => {
  console.log(2)
  Promise.resolve().then(() => {
    console.log(3)
  })
}, 0)

new Promise((resolve, reject) => {
  console.log(4)
  resolve(5)
}).then((res) => {
  console.log(res)
})

setTimeout(() => {
  console.log(6)
}, 0)

console.log(7)
// 输出结果1 4 7 5 2 3 6
```

以上代码的输出结果你猜对了吗？我们来逐行分析
-  第一行，console.log直接输出1
-  然后碰到第一个setTimeout,setTimeout属于宏任务，进入宏队列，继续往下执行
-  碰到一个promise（注意：promise只有resolve/reject才算异步）,所以这里4直接输出，resolve进入微队列
-  碰到第二个setTimeout，进宏队列
-  7直接输出
-  然后看微队列，之前进队列的依次出, 队列里面只有一个promise输出5，然后队列为空
-  然后执行宏队列第一个，输出2，promise进微队列
-  执行微队列，输出3，微队列为空
-  执行宏队列第一个，输出6，到这里所有队列为空执行完毕

```js
Promise.resolve().then(() => {
  console.log('mm')
  Promise.resolve().then(() => {
    console.log('xx')
  }).then(() => {
    console.log('yy')
  })
}).then(() => {
  console.log('nn')
})
// 输出结果mm xx nn yy
```
这段代码的输出结果你猜对了吗？我们再来分析：
- 首先看代码中只有一个大promise，先执行，mm直接输出，promise进微队列，内部执行完毕
- 然后外层.then进微队列
- 执行微队列，输出xx，碰到内部.then加入队列尾部
- 输出nn
- 输出yy