# 基础理论
- 函数式编程(Functional Programming)其实相对于计算机的历史 而言是一个非常古老的概念，甚至早于第一台计算机的诞生。函 数式编程的基础模型来源于 λ (Lambda x=>x*2)演算，而 λ 演算并 非设计于在计算机上执行，它是在 20 世纪三十年代引入的一套用 于研究函数定义、函数应用和递归的形式系统。
- 函数式编程不是用函数来编程，也不是传统的面向过程编程。主 旨在于将复杂的函数符合成简单的函数(计算理论，或者递归论， 或者拉姆达演算)。运算过程尽量写成一系列嵌套的函数调用
- 真正的火热是随着React的高阶函数而逐步升温

# 范畴论Category Theory
- 函数式编程是范畴论的数学分支是一门很复杂的数学， 认为世界上所有概念体系都可以抽象出一个个范畴
- 彼此之间存在某种关系概念、事物、对象等等，都构 成范畴。任何事物只要找出他们之间的关系，就能定义
- 箭头表示范畴成员之间的关系，正式的名称叫做"态射" (morphism)。范畴论认为，同一个范畴的所有成员， 就是不同状态的"变形"(transformation)。通过"态射"， 一个成员可以变形成另一个成员。

# 函数式编程常用核心概念
- 纯函数
- 偏应用函数、函数的柯里化
- 函数组合
- Point Free
- 声明式与命令式代码
- 惰性求值

## 纯函数
> 定义：对于相同的输入，永远会得到相同的输出，而且没有任 何可观察的副作用，也不依赖外部环境的状态。

```js
var xs = [1,2,3,4,5];
// Array.slice是纯函数，因为它没有副作用，对于固定的 输入，输出总是固定的

xs.slice(0,3); // [1,2,3]
xs.slice(0,3); // [1,2,3]
```
### 优点:
```js
import _ from 'lodash';
var sin = _.memorize(x => Math.sin(x));

// 第一次计算的时候会稍慢一点
var a = sin(1);

// 第二次有了缓存，速度极快
var b = sin(1);

// 纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存性
```
### 缺点：
```js
//不纯的
var min = 18;
var checkAge = age => age > min;

//纯的，这很函数式
var checkAge = age => age > 18;

// 在不纯的版本中，checkAge不仅取决于age还有外部依赖的变量min。
// 纯的 checkAge 把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。
```

### 纯度和幂等性
幂等性是指执行无数次后还具有相同的效果，同一的参 数运行一次函数应该与连续两次结果一致。幂等性在函 数式编程中与纯度相关，但有不一致。
```js
Math.abs(Math.abs(-42))
```

## 偏应用函数
- 传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。
- 偏函数之所以“偏”，在就在于其只能处理那些能与至少 一个case语句匹配的输入，而不能处理所有可能的输入

```js
// 带一个函数参数 和 该函数的部分参数
const partial = (f, ...args) =>
(...moreArgs) => f(...args, ...moreArgs)

const add3 = (a, b, c) => a + b + c
// 偏应用 `2` 和 `3` 到 `add3` 给你一个单参数的函数

const fivePlus = partial(add3, 2, 3)
console.log(fivePlus(4)) // 9


//用bind来实现
const add1More = add3.bind(null, 2, 3)
console.log(add1More(4)) // 9
```

## 函数的柯里化
- 柯里化(Curried) 通过偏应用函数实现。
- 传递给函数一部分参数来调用它，让它返回一个函数去 处理剩下的参数
