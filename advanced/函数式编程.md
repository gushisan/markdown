# 基础理论
- 函数式编程(Functional Programming)其实相对于计算机的历史 而言是一个非常古老的概念，甚至早于第一台计算机的诞生。函 数式编程的基础模型来源于 λ (Lambda x=>x*2)演算，而 λ 演算并 非设计于在计算机上执行，它是在 20 世纪三十年代引入的一套用 于研究函数定义、函数应用和递归的形式系统。
- 函数式编程不是用函数来编程，也不是传统的面向过程编程。主 旨在于将复杂的函数符合成简单的函数(计算理论，或者递归论， 或者拉姆达演算)。运算过程尽量写成一系列嵌套的函数调用
- 真正的火热是随着React的高阶函数而逐步升温

# 范畴论Category Theory
- 函数式编程是范畴论的数学分支是一门很复杂的数学， 认为世界上所有概念体系都可以抽象出一个个范畴
- 彼此之间存在某种关系概念、事物、对象等等，都构 成范畴。任何事物只要找出他们之间的关系，就能定义
- 箭头表示范畴成员之间的关系，正式的名称叫做"态射" (morphism)。范畴论认为，同一个范畴的所有成员， 就是不同状态的"变形"(transformation)。通过"态射"， 一个成员可以变形成另一个成员。

# 函数式编程常用核心概念
- 纯函数
- 偏应用函数、函数的柯里化
- 函数组合
- Point Free
- 声明式与命令式代码
- 惰性求值

## 纯函数
> 定义：对于相同的输入，永远会得到相同的输出，而且没有任 何可观察的副作用，也不依赖外部环境的状态。

```js
var xs = [1,2,3,4,5];
// Array.slice是纯函数，因为它没有副作用，对于固定的 输入，输出总是固定的

xs.slice(0,3); // [1,2,3]
xs.slice(0,3); // [1,2,3]
```
### 优点:
```js
import _ from 'lodash';
var sin = _.memorize(x => Math.sin(x));

// 第一次计算的时候会稍慢一点
var a = sin(1);

// 第二次有了缓存，速度极快
var b = sin(1);

// 纯函数不仅可以有效降低系统的复杂度，还有很多很棒的特性，比如可缓存性
```
### 缺点：
```js
//不纯的
var min = 18;
var checkAge = age => age > min;

//纯的，这很函数式
var checkAge = age => age > 18;

// 在不纯的版本中，checkAge不仅取决于age还有外部依赖的变量min。
// 纯的 checkAge 把关键数字18硬编码在函数内部，扩展性比较差，柯里化优雅的函数式解决。
```

### 纯度和幂等性
幂等性是指执行无数次后还具有相同的效果，同一的参 数运行一次函数应该与连续两次结果一致。幂等性在函 数式编程中与纯度相关，但有不一致。
```js
Math.abs(Math.abs(-42))
```

## 偏应用函数
- 传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。
- 偏函数之所以“偏”，在就在于其只能处理那些能与至少 一个case语句匹配的输入，而不能处理所有可能的输入

```js
// 带一个函数参数 和 该函数的部分参数
const partial = (f, ...args) =>
(...moreArgs) => f(...args, ...moreArgs)

const add3 = (a, b, c) => a + b + c
// 偏应用 `2` 和 `3` 到 `add3` 给你一个单参数的函数

const fivePlus = partial(add3, 2, 3)
console.log(fivePlus(4)) // 9


//用bind来实现
const add1More = add3.bind(null, 2, 3)
console.log(add1More(4)) // 9
```

## 函数的柯里化
- 柯里化(Curried) 通过偏应用函数实现。
- 传递给函数一部分参数来调用它，让它返回一个函数去 处理剩下的参数
```js
// 柯里化之前 
function add(x, y) {
  return x + y; 
}
add(1, 2) // 3

// 柯里化之后 
function addX(y) {
  return function (x) {
    return x + y;
  }; 
}
addX(2)(1) // 3

// bind实现柯里化
function foo(p1, p2) {
  this.val = p1 + p2; 
}
var bar = foo.bind(null, "p1");
var baz = new bar("p2");
console.log(baz.val); // p1p2
```

事实上柯里化是一种“预加载”函数的方法，通过传递较少的参数， 得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种 对参数的“缓存”，是一种非常高效的编写函数的方法

## 函数组合
为了解决函数嵌套的问题，我们需要用到“函数组合”,让多个函数像拼积木一样
```js
const compose = (f, g) => (x => f(g(x)));

var first = arr => arr[0];

var reverse = arr => arr.reverse();

var last = compose(first, reverse);
console.log(last([1,2,3,4,5])); // 5
```

## Point Free
> 把一些对象自带的方法转化成纯函数,不要命名转瞬即逝的中间变量。
```js
const compose = (f, g) => (x => f(g(x)));

var toUpperCase = word => word.toUpperCase();

var split = x => (str => str.split(x));

var f = compose(split(' '), toUpperCase);
console.log(f("abcd aaa"));// [ 'ABCD', 'AAA' ]
```
这种风格能够帮助我们减少不必要的命名，让代码保持简洁和通用。

## 声明式与命令式代码
> 命令式代码的意思就是，我们通过编写一条又一条指令去让计算 机执行一些动作，这其中一般都会涉及到很多繁杂的细节。而声明式就要优雅很多了，我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。

```js
// 命令式
let ceoList = [];
for(var i = 0; i < companies.length; i++)
  ceoList.push(companies[i].CEO)
}
// 声明式
let ceoList = companies.map(c => c.CEO);
```
