# 为什么要进⾏性能优化？
> 虽然有一个所谓的8秒规则打开一个网页，用户有不同程度的耐心。作为
调查显示，如果一个网页加载时间超过4秒，流失率可能达到25%。一秒钟
延迟或3秒等待会使客户满意度降低16%。尤其是互联网用户越来越多
知情人士表示，他们对用户体验和网站加载速度会有更高的要求 
成为网站收入的关键因素。
----[性能优化白皮书](https://www.cdnetworks.com/wp-content/uploads/2019/02/CDNetworks-Content-Acceleration-White-Paper.pdf)
- 57%的⽤户更在乎⽹⻚在3秒内是否完成加载
-  52%的在线⽤户认为⽹⻚打开速度影响到他们对⽹站的忠实度
- 每慢1秒造成⻚⾯ PV(页面浏览量或点击量) 降低11%，⽤户满意度也随之降低降低16%
- 近半数移动⽤户因为在10秒内仍未打开⻚⾯从⽽放弃

# http缓存机制
试想，如果每个用户每次拿数据都直接向服务器请求，不论该数据有没有改变，这样显然是不合理的。所以浏览器中有缓存这个概念，合理的运用浏览器的缓存可以达到访问性能优化的效果

首先了解一下缓存的优先级，以下由优先级低到高依次介绍
##  `last-modified / if-modified-since`

这是⼀组请求/相应头

响应头：
last-modified: Wed, 16 May 2020 02:57:16 GMT

请求头：
if-modified-since: Wed, 16 May 2020 05:55:38 GMT

服务器端返回资源时，如果头部带上了 last-modified，那么
资源下次请求时就会把值加⼊到请求头 if-modified-since
中，服务器可以对⽐这个值，确定资源是否发⽣变化，如果
没有发⽣变化，则返回 304。

## `etag / if-none-match`
这也是⼀组请求/相应头 响应头：

etag: "D5FC8B85A045FF720547BC36FC872550"

请求头：
if-none-match: "D5FC8B85A045FF720547BC36FC872550"

原理类似，服务器端返回资源时，如果头部带上了 etag，那么资源下
次请求时就会把值加⼊到请求头 if-none-match 中，服务器可以对⽐
这个值，确定资源是否发⽣变化，如果没有发⽣变化，则返回 304。

## `expires`
expires: Thu, 16 May 2019 03:05:59 GMT

在 http 头中设置⼀个过期时间，在这个过期时间之前，浏览器的请求都不会发出，⽽是⾃动从缓存中读取⽂件，除⾮缓存被清空，或者强制刷新。缺陷在于，服务器时间和⽤户端时间可能存在不⼀致，所以 HTTP/1.1 加⼊了 cache-control 头来改进这个问题。

## `cache-control`
设置过期的时间⻓度（秒），在这个时间范围内，浏览器请求都会直
接读缓存。当 expires 和 cache-control 都存在时，cache-control 的优先级更⾼。

## 总结
了解以上缓存的优先级后，我们大概可以复现浏览器在请求数据时所经过的步骤

![image.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3298907ef58a4b1b87c44fc494591ba2~tplv-k3u1fbpfcp-watermark.image)

当然，有时候缓存也是一个令人头痛的东西，在日常开发中，常常遇到以下这种场景。
> 公司的h5项目新一期需求开发完毕，提交代码，Jenkins构建一气呵成，然后叫qa来测试。这时qa那边进网页看到的并不是最新构建的页面。好家伙，然后qa就来找你麻烦，最后发现是缓存的问题。于是，你每次构建完毕之后都叫qa清缓存， emmm

其实出现上述问题完全是缓存造成的原因，你虽然构建完毕了，但是存在强缓，并不会去服务器拉取最新构建的代码，其实解决方法也很简单，简单粗暴，直接在index.html中禁用强缓
```html
<meta http-equiv="Cache-control" content="no-cache,max-age=0, must-revalidate,no-store">
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="0" />
```
## 一些概念
- `TTFB` Time To First Byte, ⾸字节
时间
- `FP` First Paint, ⾸次绘制
- `FCP` First Contentful Paint, ⾸次
有内容的绘制
- `FMP` First Meaningful Paint, ⾸
次有意义的绘制
- `TTI` Time To Interactive, 可交互
时间
- `Long tasks` 超过了 50ms 的任务
- `SSR&&CSR` 服务端渲染和客户端渲染
- `Isomorphic JavaScript` 同构化